getwd()
NFIparams<- prepInputs(targetFile = "C:/Celine/github/LandRCBM_split3pools/data/all_prop_models_bc_tb.csv",
fun = "data.table::fread",
destinationPath = dPath,
#purge = 7,
filename2 = "all_prop_models_bc_tb.csv")
Rversion <- gsub(".+(4..).+", "\\1", R.version.string)
rlib <- file.path("R", Rversion)
# options(repos = c(CRAN = "https://cloud.r-project.org"))
if (!dir.exists(rlib)) dir.create(rlib, recursive = TRUE); .libPaths(rlib, include.site = FALSE)
### In this section, only load the minimum of packages (Require, SpaDES.install) so all packages can be installed with
#    correct version numbering. If we load a package too early and it is an older version that what may be required by
#    a module, then we get an inconsistency
if (!require("remotes")) {
install.packages("remotes")
}
remotes::install_github("PredictiveEcology/Require@development")
Rversion <- gsub(".+(4..).+", "\\1", R.version.string)
rlib <- file.path("R", Rversion)
options(repos = c(CRAN = "https://cloud.r-project.org"))
if (!dir.exists(rlib)) dir.create(rlib, recursive = TRUE); .libPaths(rlib, include.site = FALSE)
### In this section, only load the minimum of packages (Require, SpaDES.install) so all packages can be installed with
#    correct version numbering. If we load a package too early and it is an older version that what may be required by
#    a module, then we get an inconsistency
if (!require("remotes")) {
install.packages("remotes")
}
install.packages("remotes")
remotes::install_github("PredictiveEcology/Require@f2c791eb05fb0ad99b278619198ef925f85cbb9d")
install.packages("remotes")
install.packages("remotes")
install.packages("remotes")
install.packages("remotes")
Rversion <- gsub(".+(4..).+", "\\1", R.version.string)
rlib <- file.path("R", Rversion)
options(repos = c(CRAN = "https://cloud.r-project.org"))
if (!dir.exists(rlib)) dir.create(rlib, recursive = TRUE); .libPaths(rlib, include.site = FALSE)
install.packages("C:/Celine/github/remotes_2.4.2.tar.gz", repos = NULL, type = "source")
remotes::install_github("PredictiveEcology/Require@f2c791eb05fb0ad99b278619198ef925f85cbb9d")
library(Require)
install.packages("data.table")
install.packages("data.table")
install.packages("remotes")
install.packages("remotes")
install.packages("remotes")
options(repos = c(CRAN = "https://mirror.rcg.sfu.ca/mirror/CRAN/"))
install.packages("remotes")
download.file("https://cran.r-project.org/CRAN_mirrors.csv", destfile = tempfile())
install.packages("remotes")
install.packages("data.table")
install.packages("remotes")
remotes::install_github("PredictiveEcology/Require@f2c791eb05fb0ad99b278619198ef925f85cbb9d")
#Rversion <- gsub(".+(4..).+", "\\1", R.version.string)
#rlib <- file.path("R", Rversion)
rlib <- file.path(tools::R_user_dir(basename(prjDir), "data"), "packages",
version$platform, getRversion()[,1:2])
options(repos = c(CRAN = "https://cloud.r-project.org"))
if (!dir.exists(rlib)) dir.create(rlib, recursive = TRUE); .libPaths(rlib, include.site = FALSE)
#Rversion <- gsub(".+(4..).+", "\\1", R.version.string)
#rlib <- file.path("R", Rversion)
rlib <- file.path(tools::R_user_dir(basename(prjDir), "data"), "packages",
version$platform, getRversion()[,1:2])
#Rversion <- gsub(".+(4..).+", "\\1", R.version.string)
#rlib <- file.path("R", Rversion)
rlib <- file.path(tools::R_user_dir(basename(prjDir), "data"), "packages",
version$platform, getRversion()[,1:2])
getwd()
#Rversion <- gsub(".+(4..).+", "\\1", R.version.string)
#rlib <- file.path("R", Rversion)
rlib <- file.path(tools::R_user_dir(basename(getwd()), "data"), "packages",
version$platform, getRversion()[,1:2])
options(repos = c(CRAN = "https://cloud.r-project.org"))
if (!dir.exists(rlib)) dir.create(rlib, recursive = TRUE); .libPaths(rlib, include.site = FALSE)
### In this section, only load the minimum of packages (Require, SpaDES.install) so all packages can be installed with
#    correct version numbering. If we load a package too early and it is an older version that what may be required by
#    a module, then we get an inconsistency
if (!require("remotes")) {
install.packages("remotes")
}
remotes::install_github("PredictiveEcology/Require@f2c791eb05fb0ad99b278619198ef925f85cbb9d")
library(Require)
Require(c("PredictiveEcology/SpaDES.project@transition"), require = FALSE)
Require(c("SpaDES", "reproducible"), upgrade = FALSE, install = TRUE)
remotes::install_github("PredictiveEcology/SpaDES.project@transition")
Require(c("SpaDES", "reproducible"), upgrade = FALSE, install = TRUE)
### Not sure  if I need the next line - ran it anyway
Require(c("SpaDES.core (>=1.1.0)", "SpaDES.tools (>= 1.0.0)",
"googledrive", 'RCurl', 'XML', "PredictiveEcology/CBMutils@development",
"data.table"), # comes up with an error so added "devtools'
#require = "SpaDES.core", # call `require` only on this package (same as `library`)
verbose = 1)
### Not sure  if I need the next line - ran it anyway
Require(c("SpaDES.core (>=1.1.0)", "SpaDES.tools (>= 1.0.0)",
"googledrive", 'RCurl', 'XML', #"PredictiveEcology/CBMutils@development",
"data.table"), # comes up with an error so added "devtools'
#require = "SpaDES.core", # call `require` only on this package (same as `library`)
verbose = 1)
load_all("C:/Celine/github/CBMutils")
options("download.file.method" = "libcurl")
download.file("https://cran.r-project.org/CRAN_mirrors.csv", destfile = tempfile())
options("download.file.method" = "curl")
download.file("https://cran.r-project.org/CRAN_mirrors.csv", destfile = tempfile())
options("download.file.method" = "wget")
download.file("https://cran.r-project.org/CRAN_mirrors.csv", destfile = tempfile())
options("download.file.method" = "internal")
download.file("https://cran.r-project.org/CRAN_mirrors.csv", destfile = tempfile())
options("download.file.method" = "wininet")
download.file("https://cran.r-project.org/CRAN_mirrors.csv", destfile = tempfile())
rlib <- file.path(tools::R_user_dir(basename(getwd()), "data"), "packages",
version$platform, getRversion()[,1:2])
options(repos = c(CRAN = "https://cloud.r-project.org"))
if (!dir.exists(rlib)) dir.create(rlib, recursive = TRUE); .libPaths(rlib, include.site = FALSE)
if (!require("remotes")) {
install.packages("remotes")
}
install.packages("remotes")
getOption("repos")
options("download.file.method" = "wininet")
rlib <- file.path(tools::R_user_dir(basename(getwd()), "data"), "packages",
version$platform, getRversion()[,1:2])
options(repos = c(CRAN = "https://cloud.r-project.org"))
if (!dir.exists(rlib)) dir.create(rlib, recursive = TRUE); .libPaths(rlib, include.site = FALSE)
install.packages("remotes")
install.packages("remotes")
rlib <- file.path(tools::R_user_dir(basename(getwd()), "data"), "packages",
version$platform, getRversion()[,1:2])
options(repos = c(CRAN = "https://cloud.r-project.org"))
if (!dir.exists(rlib)) dir.create(rlib, recursive = TRUE); .libPaths(rlib, include.site = FALSE)
options("download.file.method" = "wininet")
### In this section, only load the minimum of packages (Require, SpaDES.install) so all packages can be installed with
#    correct version numbering. If we load a package too early and it is an older version that what may be required by
#    a module, then we get an inconsistency
if (!require("remotes")) {
install.packages("remotes")
}
install.packages("remotes")
install.packages("remotes")
remotes::install_github("PredictiveEcology/Require@f2c791eb05fb0ad99b278619198ef925f85cbb9d")
remotes::install_github("PredictiveEcology/Require@development")
library(Require)
Require(c("PredictiveEcology/SpaDES.project@transition"), require = FALSE)
rlib <- file.path(tools::R_user_dir(basename(getwd()), "data"), "packages",
version$platform, getRversion()[,1:2])
options(repos = c(CRAN = "https://cloud.r-project.org"))
if (!dir.exists(rlib)) dir.create(rlib, recursive = TRUE); .libPaths(rlib, include.site = FALSE)
### In this section, only load the minimum of packages (Require, SpaDES.install) so all packages can be installed with
#    correct version numbering. If we load a package too early and it is an older version that what may be required by
#    a module, then we get an inconsistency
if (!require("remotes")) {
install.packages("remotes")
}
remotes::install_github("PredictiveEcology/Require@development")
library(Require)
Require(c("PredictiveEcology/SpaDES.project@transition"), require = FALSE)
rlib
pkgDir <- file.path(tools::R_user_dir(basename(getwd()), "data"), "packages",
version$platform, getRversion()[, 1:2])
dir.create(pkgDir, recursive = TRUE, showWarnings = FALSE)
.libPaths(pkgDir, include.site = FALSE)
install.packages("remotes")
install.packages("remotes")
pkgDir <- file.path(tools::R_user_dir(basename(getwd()), "data"), "packages",
version$platform, getRversion()[, 1:2])
dir.create(pkgDir, recursive = TRUE, showWarnings = FALSE)
.libPaths(pkgDir, include.site = FALSE)
install.packages("remotes")
install.packages("remotes")
pkgDir <- file.path(tools::R_user_dir(basename(getwd()), "data"), "packages",
version$platform, getRversion()[, 1:2])
dir.create(pkgDir, recursive = TRUE, showWarnings = FALSE)
.libPaths(pkgDir, include.site = FALSE)
# rlib <- file.path(tools::R_user_dir(basename(getwd()), "data"), "packages",
#                     version$platform, getRversion()[,1:2])
# options(repos = c(CRAN = "https://cloud.r-project.org"))
# if (!dir.exists(rlib)) dir.create(rlib, recursive = TRUE); .libPaths(rlib, include.site = FALSE)
## this is a work-around for working from PFC...R cannot connect to URL
options("download.file.method" = "wininet")
### In this section, only load the minimum of packages (Require, SpaDES.install) so all packages can be installed with
#    correct version numbering. If we load a package too early and it is an older version that what may be required by
#    a module, then we get an inconsistency
if (!require("remotes")) {
install.packages("remotes")
}
remotes::install_github("PredictiveEcology/Require@development")
library(Require)
library(Require)
detach("package:Require", unload = TRUE)
remove.packages("Require")
remotes::install_github("PredictiveEcology/Require@development")
library(Require)
Require(c("PredictiveEcology/SpaDES.project@transition"), require = FALSE)
remove.packages("SpaDES.project")
library(Require)
remove.packages("Require")
library(Require)
remotes::install_github("PredictiveEcology/Require@development")
library(Require)
packageVersion("Require")
libPaths
.libPaths()
pkgDir <- file.path(tools::R_user_dir(basename(getwd()), "data"), "packages",
version$platform, getRversion()[, 1:2])
dir.create(pkgDir, recursive = TRUE, showWarnings = FALSE)
.libPaths(pkgDir, include.site = FALSE)
options("download.file.method" = "wininet")
### In this section, only load the minimum of packages (Require, SpaDES.install) so all packages can be installed with
#    correct version numbering. If we load a package too early and it is an older version that what may be required by
#    a module, then we get an inconsistency
if (!require("remotes")) {
install.packages("remotes")
}
remotes::install_github("PredictiveEcology/Require@development")
library(Require)
## install/load required packages
#Rversion <- gsub(".+(4..).+", "\\1", R.version.string)
#rlib <- file.path("R", Rversion)
pkgDir <- file.path(tools::R_user_dir(basename(getwd()), "data"), "packages",
version$platform, getRversion()[, 1:2])
dir.create(pkgDir, recursive = TRUE, showWarnings = FALSE)
.libPaths(pkgDir, include.site = FALSE)
# rlib <- file.path(tools::R_user_dir(basename(getwd()), "data"), "packages",
#                     version$platform, getRversion()[,1:2])
# options(repos = c(CRAN = "https://cloud.r-project.org"))
# if (!dir.exists(rlib)) dir.create(rlib, recursive = TRUE); .libPaths(rlib, include.site = FALSE)
## this is a work-around for working from PFC...R cannot connect to URL
options("download.file.method" = "wininet")
### In this section, only load the minimum of packages (Require, SpaDES.install) so all packages can be installed with
#    correct version numbering. If we load a package too early and it is an older version that what may be required by
#    a module, then we get an inconsistency
if (!require("remotes")) {
install.packages("remotes")
}
remotes::install_github("PredictiveEcology/Require@development")
loadedNamespaces()
loadedNamespaces()
loadedNamespaces()
loadedNamespaces()
loadedNamespaces()
loadedNamespaces()
loadedNamespaces()
loadedNamespaces()
pkgDir <- file.path(tools::R_user_dir(basename(getwd()), "data"), "packages",
version$platform, getRversion()[, 1:2])
dir.create(pkgDir, recursive = TRUE, showWarnings = FALSE)
.libPaths(pkgDir, include.site = FALSE)
# rlib <- file.path(tools::R_user_dir(basename(getwd()), "data"), "packages",
#                     version$platform, getRversion()[,1:2])
# options(repos = c(CRAN = "https://cloud.r-project.org"))
# if (!dir.exists(rlib)) dir.create(rlib, recursive = TRUE); .libPaths(rlib, include.site = FALSE)
## this is a work-around for working from PFC...R cannot connect to URL
options("download.file.method" = "wininet")
### In this section, only load the minimum of packages (Require, SpaDES.install) so all packages can be installed with
#    correct version numbering. If we load a package too early and it is an older version that what may be required by
#    a module, then we get an inconsistency
if (!require("remotes")) {
install.packages("remotes")
}
remotes::install_github("PredictiveEcology/Require@development")
library(Require)
loadedNamespaces()
pkgDir <- file.path(tools::R_user_dir(basename(getwd()), "data"), "packages",
version$platform, getRversion()[, 1:2])
dir.create(pkgDir, recursive = TRUE, showWarnings = FALSE)
.libPaths(pkgDir, include.site = FALSE)
# rlib <- file.path(tools::R_user_dir(basename(getwd()), "data"), "packages",
#                     version$platform, getRversion()[,1:2])
# options(repos = c(CRAN = "https://cloud.r-project.org"))
# if (!dir.exists(rlib)) dir.create(rlib, recursive = TRUE); .libPaths(rlib, include.site = FALSE)
## this is a work-around for working from PFC...R cannot connect to URL
options("download.file.method" = "wininet")
if (!require("remotes")) {
install.packages("remotes")
}
remotes::install_github("PredictiveEcology/Require@development")
remotes::install_github("PredictiveEcology/Require@development")
library(Require)
### Not sure  if I need the next line - ran it anyway
Require(c("PredictiveEcology/SpaDES.project@transition", "SpaDES", "reproducible",
"SpaDES.core (>=1.1.0)", "SpaDES.tools (>= 1.0.0)",
"googledrive", 'RCurl', 'XML', "PredictiveEcology/CBMutils@development",
"data.table", "devtools"), # comes up with an error so added "devtools'
require = c("SpaDES.core", "devtools"), # call `require` only on this package (same as `library`)
verbose = 1)
load_all("C:/Celine/github/CBMutils")
table6 <- prepInputs(url = "https://drive.google.com/file/d/1gvtV-LKBNbqD7hmlL4X0i40P3du75oJc/view?usp=sharing",
fun = "data.table::fread",
destinationPath = "C:/Celine/github/LandRCBM_split3pools/inputs",
#purge = 7,
filename2 = "appendix2_table6_tb.csv")
table7 <- prepInputs(url = "https://drive.google.com/file/d/16nQgTGW2p_IYF_Oavcc7WbWbgWl5uywt/view?usp=sharing",
fun = "data.table::fread",
destinationPath = "C:/Celine/github/LandRCBM_split3pools/inputs",
#purge = 7,
filename2 = "appendix2_table7_tb.csv")
cbmAdmin <-  prepInputs(url = "https://drive.google.com/file/d/1NwVPqMho8fOcf9mVVzm5SlfDbbyQmQlh/view?usp=sharing",
fun = "data.table::fread",
destinationPath = "C:/Celine/github/LandRCBM_split3pools/inputs",
#purge = 7,
filename2 = "cbmAdmin.csv")
## we need the studyArea
RIArtm <- prepInputs(url = "https://drive.google.com/file/d/1h7gK44g64dwcoqhij24F2K54hs5e35Ci/view?usp=sharing",
destinationPath = "C:/Celine/github/LandRCBM_split3pools/inputs")
ecozone <- CBMutils::prepInputsEcozones(url = "http://sis.agr.gc.ca/cansis/nsdb/ecostrat/zone/ecozone_shp.zip",
dPath =  "C:/Celine/github/LandRCBM_split3pools/inputs",
rasterToMatch = RIArtm)
## we need the studyArea
RIArtm <- prepInputs(url = "https://drive.google.com/file/d/1h7gK44g64dwcoqhij24F2K54hs5e35Ci/view?usp=sharing",
destinationPath = "C:/Celine/github/LandRCBM_split3pools/inputs")
ecozone <- CBMutils::prepInputsEcozones(url = "http://sis.agr.gc.ca/cansis/nsdb/ecostrat/zone/ecozone_shp.zip",
dPath =  "C:/Celine/github/LandRCBM_split3pools/inputs",
rasterToMatch = RIArtm)
canfi_species <- prepInputs(url = "https://drive.google.com/file/d/1l9b9V7czTZdiCIFX3dsvAsKpQxmN-Epo",
fun = "data.table::fread",
destinationPath = "C:/Celine/github/LandRCBM_split3pools/inputs",
filename2 = "canfi_species.csv")
## these two next tables will be coming from the Yield module
## this one is the actual yields
CBM_AGB <- prepInputs(url = "https://drive.google.com/file/d/1xxfG-8ZJKPlO5HguHpVtqio5TXdcRGy7",
fun = "data.table::fread",
destinationPath = "C:/Celine/github/LandRCBM_split3pools/inputs",
filename2 = "CBM_AGB.csv")
## not sure why that extra column is added
CBM_AGB <- CBM_AGB[,2:6]
## this is the species matching the Sp1 Sp2 and Sp3 of the previous table
CBM_speciesCodes <- prepInputs(url = "https://drive.google.com/file/d/1sVsDoT1E-CDgo2hnCU2pgqV6PpVic2Fe",
fun = "data.table::fread",
destinationPath = "C:/Celine/github/LandRCBM_split3pools/inputs",
filename2 = "CBM_speciesCodes.csv"
# , useCache = FALSE
)
## not sure why that extra column is added
CBM_speciesCodes <- CBM_speciesCodes[,2:4]
### SOMETHING IS MISSING
# there are multiple species that are Sp1 depending on the
unique(CBM_speciesCodes[,c("speciesCode", "Sp")])
## read-in the pixelGroupMap
pixelGroupMap <- Cache(prepInputs, url = "https://drive.google.com/file/d/1Pso52N9DFVJ46OFxtvtqrVX9VzOVhcf3",
destinationPath = "C:/Celine/github/LandRCBM_split3pools/inputs",
rasterToMatch = RIArtm)
pkgDir <- file.path(tools::R_user_dir(basename(getwd()), "data"), "packages",
version$platform, getRversion()[, 1:2])
dir.create(pkgDir, recursive = TRUE, showWarnings = FALSE)
.libPaths(pkgDir, include.site = FALSE)
install.packages("remotes")
options("download.file.method" = "wininet")
install.packages("remotes")
remotes::install_github("PredictiveEcology/Require@development")
library(Require)
### Not sure  if I need the next line - ran it anyway
Require(c("PredictiveEcology/SpaDES.project@transition", "SpaDES", "reproducible",
"SpaDES.core (>=1.1.0)", "SpaDES.tools (>= 1.0.0)",
"googledrive", 'RCurl', 'XML', "PredictiveEcology/CBMutils@development",
"data.table", "devtools"), # comes up with an error so added "devtools'
require = c("SpaDES.core", "devtools"), # call `require` only on this package (same as `library`)
verbose = 1)
load_all("C:/Celine/github/CBMutils")
##############################################################
# 1. This is all input data - expectsInputs() and .inputObject
## Read in two parameter tables
table6 <- prepInputs(url = "https://drive.google.com/file/d/1gvtV-LKBNbqD7hmlL4X0i40P3du75oJc/view?usp=sharing",
fun = "data.table::fread",
destinationPath = "C:/Celine/github/LandRCBM_split3pools/inputs",
#purge = 7,
filename2 = "appendix2_table6_tb.csv")
table7 <- prepInputs(url = "https://drive.google.com/file/d/16nQgTGW2p_IYF_Oavcc7WbWbgWl5uywt/view?usp=sharing",
fun = "data.table::fread",
destinationPath = "C:/Celine/github/LandRCBM_split3pools/inputs",
#purge = 7,
filename2 = "appendix2_table7_tb.csv")
cbmAdmin <-  prepInputs(url = "https://drive.google.com/file/d/1NwVPqMho8fOcf9mVVzm5SlfDbbyQmQlh/view?usp=sharing",
fun = "data.table::fread",
destinationPath = "C:/Celine/github/LandRCBM_split3pools/inputs",
#purge = 7,
filename2 = "cbmAdmin.csv")
## we need the studyArea
RIArtm <- prepInputs(url = "https://drive.google.com/file/d/1h7gK44g64dwcoqhij24F2K54hs5e35Ci/view?usp=sharing",
destinationPath = "C:/Celine/github/LandRCBM_split3pools/inputs")
ecozone <- CBMutils::prepInputsEcozones(url = "http://sis.agr.gc.ca/cansis/nsdb/ecostrat/zone/ecozone_shp.zip",
dPath =  "C:/Celine/github/LandRCBM_split3pools/inputs",
rasterToMatch = RIArtm)
ecozone
canfi_species <- prepInputs(url = "https://drive.google.com/file/d/1l9b9V7czTZdiCIFX3dsvAsKpQxmN-Epo",
fun = "data.table::fread",
destinationPath = "C:/Celine/github/LandRCBM_split3pools/inputs",
filename2 = "canfi_species.csv")
## these two next tables will be coming from the Yield module
## this one is the actual yields
CBM_AGB <- prepInputs(url = "https://drive.google.com/file/d/1xxfG-8ZJKPlO5HguHpVtqio5TXdcRGy7",
fun = "data.table::fread",
destinationPath = "C:/Celine/github/LandRCBM_split3pools/inputs",
filename2 = "CBM_AGB.csv")
## not sure why that extra column is added
CBM_AGB <- CBM_AGB[,2:6]
## this is the species matching the Sp1 Sp2 and Sp3 of the previous table
CBM_speciesCodes <- prepInputs(url = "https://drive.google.com/file/d/1sVsDoT1E-CDgo2hnCU2pgqV6PpVic2Fe",
fun = "data.table::fread",
destinationPath = "C:/Celine/github/LandRCBM_split3pools/inputs",
filename2 = "CBM_speciesCodes.csv"
# , useCache = FALSE
)
## not sure why that extra column is added
CBM_speciesCodes <- CBM_speciesCodes[,2:4]
### SOMETHING IS MISSING
# there are multiple species that are Sp1 depending on the
unique(CBM_speciesCodes[,c("speciesCode", "Sp")])
## read-in the pixelGroupMap
pixelGroupMap <- Cache(prepInputs, url = "https://drive.google.com/file/d/1Pso52N9DFVJ46OFxtvtqrVX9VzOVhcf3",
destinationPath = "C:/Celine/github/LandRCBM_split3pools/inputs",
rasterToMatch = RIArtm)
##TODO
## Are pixelGroupMap and ecozone the same RTM?
length(pixelGroupMap[])
length(ecozone[])
pixelGroupEco <- as.data.table(cbind(pixelIndex = 1:ncell(pixelGroupMap),
pixelGroup = pixelGroupMap[],
ecozone = ecozone[]))
### limiting this to our pixelGroups
pixelGroupEco <- pixelGroupEco[, "pixelIndex" := NULL][pixelGroup %in% 1:3,]
pixelGroupEco <- unique(pixelGroupEco)
### matching the ecozone to the admin, for now this is done by hand...
##TODO make the matching to the admin abreviation automatic.
juris_id <- cbmAdmin[(EcoBoundaryID %in% pixelGroupEco$ecozone) & abreviation == "BC",]$abreviation
pixelGroupEco[, juris_id := juris_id]
setnames(CBM_AGB,"id","pixelGroup")
CBM_AGB <- CBM_AGB[pixelGroup %in% 1:3,]
cbm1 <- melt.data.table(CBM_AGB, id.vars = c("pixelGroup", "age"), variable.name = "Sp", value.name = "B")
keycols1 = c("pixelGroup", "Sp")
setkeyv(cbm1, keycols1)
setkeyv(CBM_speciesCodes, keycols1)
CBM_yieldOut <- merge(cbm1, CBM_speciesCodes, by = c("pixelGroup", "Sp"))
CBM_yieldOut <- CBM_yieldOut[,-"Sp"]
## just working with what we have
matchCanfi <- as.data.table(cbind(speciesCode = unique(CBM_yieldOut$speciesCode),
canfi_species = c(1303, 105, 101)))
CBM_yieldOut <- merge(CBM_yieldOut, matchCanfi, by = "speciesCode")
CBM_yieldOut[, id := pixelGroup]
counter <- 0L
cumBiomList <- list()
allInfoAGBin <- merge(CBM_yieldOut,pixelGroupEco, by = "pixelGroup")
allInfoAGBin
length(unique(allInfoAGBin$canfi_species))
i=1
# matching on species name
oneSpecies <- allInfoAGBin[canfi_species == unique(CBM_yieldOut$canfi_species)[i], ]#gcMeta[species == fullSpecies #speciesMeta
oneSpecies
j in 1:NROW(unique(oneSpecies, on = "id"))
unique(speciesMeta, on = "gcids")
unique(oneSpecies, on = "id"))
unique(oneSpecies, on = "id")
NROW(unique(oneSpecies, on = "pixelGroup"))
?NROW
ma <- matrix(1:12, 3, 4)
ma
unique(oneSpecies$pixelGroup)
unique(oneSpecies$id)
## the 1:NROW seems to not work (have not determined why it does not cycle
## through the #rows for each id).
##TODO
##fix this work around
idj <- unique(oneSpecies$id)
## the 1:NROW seems to not work (have not determined why it does not cycle
## through the #rows for each id).
##TODO
##fix this work around
idj <- unique(oneSpecies$id)
j=1
i
j
length(oneSpecies[id == idj[j],])
oneSpecies
table(oneSpecies$id)
idj[j]
oneSpecies[id == 1,]
length(oneSpecies[id == 1,])
nrow(oneSpecies[id == idj[j],])
NROW(oneSpecies[id == idj[j],])
